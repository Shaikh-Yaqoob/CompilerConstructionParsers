
# -*- coding: utf-8 -*-
"""Percedence_operator_parser.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VNlU-GaWbKMf5qZgvdDOqRaHhNQVI01y
"""

import numpy as np  # Importing the numpy library to use arrays and matrix operations

# Function to check the operator precedence relations for a given input string
def stringcheck():
    # Taking input for operators and terminals (user is instructed to input non-terminals in lowercase)
    a = list(input("Enter the operator used in the given grammar including the terminals\n non-terminals should be in cursive(small)letter"))
    a.append('$')  # Appending the special end-of-input symbol '$' to the list
    print(a)  # Print the list of operators and terminals

    l = list("abcdefghijklmnopqrstuvwxyz")  # List of lowercase letters (used to check if a character is a terminal)
    o = list('(/*%+-)')  # List of operator symbols used in precedence checking
    p = list('(/*%+-)')  # Same as above for precedence checking

    # Creating a square matrix 'n' to store precedence relations between symbols
    n = np.empty([len(a)+1, len(a)+1], dtype=str, order="C")

    # Initializing the first row and column with the symbols (operators and terminals)
    for j in range(1, len(a)+1):
        n[0][j] = a[j-1]
        n[j][0] = a[j-1]

    # Filling the precedence relation matrix based on the input operators and terminals
    for i in range(1, len(a)+1):
        for j in range(1, len(a)+1):
            # If both symbols are terminals (lowercase letters), no precedence relation
            if (n[i][0] in l) and (n[0][j] in l):
                n[i][j] = ""
            # If the first symbol is a terminal and second is an operator, assign '>'
            elif (n[i][0] in l):
                n[i][j] = ">"
            # If both are operators, determine precedence using the index of operators
            elif (n[i][0] in o) and (n[0][j] in o):
                if (o.index(n[i][0]) <= o.index(n[0][j])):
                    n[i][j] = ">"
                else:
                    n[i][j] = "<"
            # If the first is an operator and the second is a terminal, assign '<'
            elif (n[i][0] in o) and (n[0][j] in l):
                n[i][j] = "<"
            # If the first symbol is '$' (end of input), assign '<' for other symbols
            elif (n[i][0] == "$" and n[0][j] != "$"):
                n[i][j] = "<"
            # If the second symbol is '$', assign '>' for all other symbols
            elif (n[0][j] == "$" and n[i][0] != "$"):
                n[i][j] = ">"
            else:
                break  # If no conditions are met, break the loop

    # Printing the generated precedence relational table
    print("The Operator Precedence Relational Table\n=============================================")
    print(n)

    # Taking input string to be checked for its acceptance
    i = list(input("Enter the string want to be checked(non-terminals should be in cursive(small) letter..."))
    i.append("$")  # Appending the end-of-input symbol to the string
    s = [None] * len(i)  # Initializing the stack for parsing
    q = 0  # Stack pointer
    s.insert(q, "$")  # Inserting '$' at the start of the stack

    # Extracting row and column headers from the precedence table
    x = [row[0] for row in n]
    y = list(n[0])
    h = 0  # Pointer for the input string

    # Loop until the stack is empty or the string is parsed correctly
    while s[0] != s[1]:
        # Check if the last character of the input string is an operator, if so, stop
        if i[len(i)-2] in p:
            break
        # Check if the top of the stack and current symbol are valid for precedence checking
        elif (s[q] in x) and (i[h] in y):
            # If the precedence relation is '<', shift by pushing the symbol onto the stack
            if n[x.index(s[q])][y.index(i[h])] == "<":
                q += 1
                s.insert(q, i[h])
                h += 1
            # If the precedence relation is '>', reduce by popping the top of the stack
            elif n[x.index(s[q])][y.index(i[h])] == ">":
                s.pop(q)
                q -= 1
            # If both symbols are '$', accept the string
            elif (n[x.index(s[q])][y.index(i[h])] == '') and (s[q] == "$") and (i[h] == "$"):
                s[1] = s[0]
        else:
            break  # If no valid precedence relation is found, break the loop

    # Check if the string is accepted or not
    if s[0] != s[1]:
        return False  # If the stack is not empty, return False
    else:
        return True  # Otherwise, return True (string is accepted)

# Function to check if the given grammar is valid
def grammarcheck(i):
    print("Enter the", str(i + 1) + "th grammar(production) want to be checked\n For null production please enter any special symbol or whitespace...")
    b = list(input().split("->"))  # Splitting the grammar into LHS and RHS
    f = list("abcdefghijklmnopqrstuvwxyz")  # List of lowercase letters to check for terminals

    # Check if the left-hand side (LHS) is valid (not empty, not a terminal, and not null production)
    if b[0] == " " or b[0] == "" or b[0] in f or len(b) == 1:
        return False  # If invalid, return False
    else:
        b.pop(0)  # Remove the LHS from the list
        b = list(b[0])  # Take RHS as a list
        s = list("ABCDEFGHIJKLMNOPQRSTUVWXYZ")  # List of uppercase letters for non-terminals
        o = list("(abcdefghijklmnopqrstuvwxyz^/*+-|)")  # Operators and symbols used in grammar
        sp = ['!', '@', '#', '$', '?', '~', '`', ',', ';', ':', '"', '=', '_', '&', "'", "", " "]  # Special symbols

        # Check validity of RHS symbols based on rules
        for i in range(0, len(b), 2):
            if b[i] == " ":
                g = False  # If space is encountered, invalid production
            elif b[i] in sp:
                g = False  # If special symbol is encountered, invalid production
                break
            # Check if parentheses are balanced and valid
            elif b[len(b) - 1] in o and ((b[0] == "(" and b[len(b) - 1] == ")") or (b.count("(") == b.count(")"))):
                g = True
            # Check if terminal symbols are valid
            elif b[i] in f:
                g = True
            elif b[len(b) - 1] in o:
                g = False
            elif (i == len(b) - 1) and (b[i] in s):
                g = True
            elif (i == len(b) - 1) and (b[i] not in s) and (b[i] in o) and b[i - 1] in o:
                g = True
            elif (b[i] in s) and (b[i + 1] in o):
                g = True
            elif (b[i] in s) and (b[i + 1] in s):
                g = False  # If two non-terminals are adjacent, invalid production
                break
            else:
                g = False  # If none of the conditions are met, invalid production
                break

        # Return True if valid, otherwise False
        if g == True:
            return True
        else:
            return False

# Main function to drive the program
while True:  # Loop to keep taking inputs until the user decides to stop
    # Taking input for the number of LHS variables in the grammar
    c = int(input("Enter the number of LHS variables..\n"))
    # Check each grammar production using grammarcheck function
    for i in range(c):
        if grammarcheck(i):
            t = True  # If valid grammar, continue checking
        else:
            t = False  # If invalid grammar, stop checking
            break

    # If all grammar productions are valid, check if the string is accepted
    if t:
        print("Grammar is accepted")  # If grammar is valid, print accepted
        if stringcheck():  # Check if the string is accepted by the grammar
            print("String is accepted")
        else:
            print("String is not accepted")
    else:
        print("Grammar is not accepted")  # If any grammar production is invalid, print not accepted

    # Ask the user if they want to input again
    cont = input("Do you want to enter new grammar and string? (yes/no): ").lower()
    if cont != "yes":  # If user does not want to continue, break the loop
        break
